<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/Projects/Games/Garden/GardenGameEffects.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Projects/Games/Garden/GardenGameEffects.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using System.Collections;&#10;using System.Collections.Generic;&#10;&#10;namespace Projects.Games.Garden&#10;{&#10;    public class GardenGameEffects : MonoBehaviour&#10;    {&#10;        [Header(&quot;Visual Effects&quot;)]&#10;        [SerializeField] private GameObject scorePopupPrefab;&#10;        [SerializeField] private Transform effectsContainer;&#10;        [SerializeField] private ParticleSystem backgroundParticles;&#10;        &#10;        [Header(&quot;Screen Effects&quot;)]&#10;        [SerializeField] private Image screenFlash;&#10;        [SerializeField] private Color flashColor = Color.white;&#10;        [SerializeField] private float flashDuration = 0.1f;&#10;        &#10;        [Header(&quot;Combo System&quot;)]&#10;        [SerializeField] private Text comboText;&#10;        [SerializeField] private float comboResetTime = 2f;&#10;        [SerializeField] private int comboMultiplier = 2;&#10;        &#10;        private int currentCombo = 0;&#10;        private float lastClickTime = 0f;&#10;        private List&lt;GameObject&gt; activePopups = new List&lt;GameObject&gt;();&#10;        &#10;        private void Start()&#10;        {&#10;            if (screenFlash != null)&#10;            {&#10;                Color color = screenFlash.color;&#10;                color.a = 0f;&#10;                screenFlash.color = color;&#10;            }&#10;            &#10;            if (comboText != null)&#10;                comboText.gameObject.SetActive(false);&#10;                &#10;            if (backgroundParticles != null)&#10;                backgroundParticles.Play();&#10;        }&#10;        &#10;        private void OnEnable()&#10;        {&#10;            GardenGameController.OnScoreChanged += OnScoreChanged;&#10;        }&#10;        &#10;        private void OnDisable()&#10;        {&#10;            GardenGameController.OnScoreChanged -= OnScoreChanged;&#10;        }&#10;        &#10;        private void Update()&#10;        {&#10;            UpdateCombo();&#10;        }&#10;        &#10;        private void OnScoreChanged(int newScore)&#10;        {&#10;            UpdateComboSystem();&#10;            CreateScreenFlash();&#10;        }&#10;        &#10;        private void UpdateComboSystem()&#10;        {&#10;            float currentTime = Time.time;&#10;            &#10;            // Если прошло меньше времени сброса комбо - увеличиваем комбо&#10;            if (currentTime - lastClickTime &lt;= comboResetTime)&#10;            {&#10;                currentCombo++;&#10;            }&#10;            else&#10;            {&#10;                currentCombo = 1; // Сбрасываем до 1 (текущий клик)&#10;            }&#10;            &#10;            lastClickTime = currentTime;&#10;            &#10;            // Показываем комбо если больше 1&#10;            if (currentCombo &gt; 1)&#10;            {&#10;                ShowCombo();&#10;            }&#10;        }&#10;        &#10;        private void UpdateCombo()&#10;        {&#10;            if (currentCombo &gt; 1 &amp;&amp; Time.time - lastClickTime &gt; comboResetTime)&#10;            {&#10;                ResetCombo();&#10;            }&#10;        }&#10;        &#10;        private void ShowCombo()&#10;        {&#10;            if (comboText == null) return;&#10;            &#10;            comboText.gameObject.SetActive(true);&#10;            comboText.text = $&quot;КОМБО x{currentCombo}!&quot;;&#10;            &#10;            // Анимация текста комбо&#10;            StopAllCoroutines();&#10;            StartCoroutine(AnimateComboText());&#10;        }&#10;        &#10;        private IEnumerator AnimateComboText()&#10;        {&#10;            if (comboText == null) yield break;&#10;            &#10;            Vector3 originalScale = comboText.transform.localScale;&#10;            Color originalColor = comboText.color;&#10;            &#10;            // Увеличиваем и делаем ярче&#10;            float duration = 0.2f;&#10;            float elapsed = 0f;&#10;            &#10;            while (elapsed &lt; duration)&#10;            {&#10;                elapsed += Time.deltaTime;&#10;                float progress = elapsed / duration;&#10;                &#10;                float scale = Mathf.Lerp(1.2f, 1f, progress);&#10;                comboText.transform.localScale = originalScale * scale;&#10;                &#10;                Color color = originalColor;&#10;                color.a = Mathf.Lerp(1f, 0.8f, progress);&#10;                comboText.color = color;&#10;                &#10;                yield return null;&#10;            }&#10;            &#10;            comboText.transform.localScale = originalScale;&#10;            comboText.color = originalColor;&#10;        }&#10;        &#10;        private void ResetCombo()&#10;        {&#10;            currentCombo = 0;&#10;            &#10;            if (comboText != null)&#10;            {&#10;                StartCoroutine(FadeOutCombo());&#10;            }&#10;        }&#10;        &#10;        private IEnumerator FadeOutCombo()&#10;        {&#10;            if (comboText == null) yield break;&#10;            &#10;            Color originalColor = comboText.color;&#10;            float duration = 0.5f;&#10;            float elapsed = 0f;&#10;            &#10;            while (elapsed &lt; duration)&#10;            {&#10;                elapsed += Time.deltaTime;&#10;                float progress = elapsed / duration;&#10;                &#10;                Color color = originalColor;&#10;                color.a = Mathf.Lerp(originalColor.a, 0f, progress);&#10;                comboText.color = color;&#10;                &#10;                yield return null;&#10;            }&#10;            &#10;            comboText.gameObject.SetActive(false);&#10;            comboText.color = originalColor; // Возвращаем исходный цвет&#10;        }&#10;        &#10;        public void CreateScorePopup(Vector3 worldPosition, int points)&#10;        {&#10;            if (scorePopupPrefab == null || effectsContainer == null) return;&#10;            &#10;            GameObject popup = Instantiate(scorePopupPrefab, effectsContainer);&#10;            &#10;            // Устанавливаем позицию&#10;            if (popup.GetComponent&lt;RectTransform&gt;() != null)&#10;            {&#10;                RectTransform rectTransform = popup.GetComponent&lt;RectTransform&gt;();&#10;                rectTransform.position = worldPosition;&#10;            }&#10;            else&#10;            {&#10;                popup.transform.position = worldPosition;&#10;            }&#10;            &#10;            // Настраиваем текст&#10;            Text popupText = popup.GetComponentInChildren&lt;Text&gt;();&#10;            if (popupText != null)&#10;            {&#10;                int finalPoints = currentCombo &gt; 1 ? points * comboMultiplier : points;&#10;                popupText.text = currentCombo &gt; 1 ? $&quot;+{finalPoints} (x{currentCombo})&quot; : $&quot;+{finalPoints}&quot;;&#10;                &#10;                // Цвет в зависимости от комбо&#10;                if (currentCombo &gt; 1)&#10;                {&#10;                    popupText.color = Color.yellow;&#10;                }&#10;            }&#10;            &#10;            activePopups.Add(popup);&#10;            StartCoroutine(AnimateScorePopup(popup));&#10;        }&#10;        &#10;        private IEnumerator AnimateScorePopup(GameObject popup)&#10;        {&#10;            if (popup == null) yield break;&#10;            &#10;            Transform popupTransform = popup.transform;&#10;            Vector3 startPosition = popupTransform.position;&#10;            Vector3 endPosition = startPosition + Vector3.up * 100f;&#10;            &#10;            Text popupText = popup.GetComponentInChildren&lt;Text&gt;();&#10;            Color originalColor = popupText != null ? popupText.color : Color.white;&#10;            &#10;            float duration = 1.5f;&#10;            float elapsed = 0f;&#10;            &#10;            while (elapsed &lt; duration &amp;&amp; popup != null)&#10;            {&#10;                elapsed += Time.deltaTime;&#10;                float progress = elapsed / duration;&#10;                &#10;                // Движение вверх&#10;                popupTransform.position = Vector3.Lerp(startPosition, endPosition, progress);&#10;                &#10;                // Затухание&#10;                if (popupText != null)&#10;                {&#10;                    Color color = originalColor;&#10;                    color.a = Mathf.Lerp(1f, 0f, progress);&#10;                    popupText.color = color;&#10;                }&#10;                &#10;                yield return null;&#10;            }&#10;            &#10;            // Удаляем popup&#10;            if (activePopups.Contains(popup))&#10;            {&#10;                activePopups.Remove(popup);&#10;            }&#10;            &#10;            if (popup != null)&#10;            {&#10;                Destroy(popup);&#10;            }&#10;        }&#10;        &#10;        private void CreateScreenFlash()&#10;        {&#10;            if (screenFlash != null)&#10;            {&#10;                StartCoroutine(FlashScreen());&#10;            }&#10;        }&#10;        &#10;        private IEnumerator FlashScreen()&#10;        {&#10;            if (screenFlash == null) yield break;&#10;            &#10;            Color color = flashColor;&#10;            color.a = 0.3f;&#10;            screenFlash.color = color;&#10;            &#10;            float elapsed = 0f;&#10;            &#10;            while (elapsed &lt; flashDuration)&#10;            {&#10;                elapsed += Time.deltaTime;&#10;                float progress = elapsed / flashDuration;&#10;                &#10;                color.a = Mathf.Lerp(0.3f, 0f, progress);&#10;                screenFlash.color = color;&#10;                &#10;                yield return null;&#10;            }&#10;            &#10;            color.a = 0f;&#10;            screenFlash.color = color;&#10;        }&#10;        &#10;        public int GetCurrentCombo() =&gt; currentCombo;&#10;        public int GetComboMultiplier() =&gt; currentCombo &gt; 1 ? comboMultiplier : 1;&#10;        &#10;        private void OnDestroy()&#10;        {&#10;            // Очищаем активные попапы&#10;            foreach (GameObject popup in activePopups)&#10;            {&#10;                if (popup != null)&#10;                {&#10;                    Destroy(popup);&#10;                }&#10;            }&#10;            activePopups.Clear();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Projects/Games/SceneSwitcher.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Projects/Games/SceneSwitcher.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.SceneManagement;&#10;using UnityEngine.UI;&#10;&#10;namespace Projects.Games&#10;{&#10;    public class SceneSwitcher : MonoBehaviour&#10;    {&#10;        [Header(&quot;UI Elements&quot;)]&#10;        [SerializeField] private Button switchSceneButton;&#10;&#10;        [Header(&quot;Scene Settings&quot;)]&#10;        [SerializeField] private string targetSceneName;&#10;&#10;        private void Start()&#10;        {&#10;            if (switchSceneButton != null)&#10;            {&#10;                switchSceneButton.onClick.AddListener(SwitchScene);&#10;            }&#10;        }&#10;&#10;        private void SwitchScene()&#10;        {&#10;            if (!string.IsNullOrEmpty(targetSceneName))&#10;            {&#10;                SceneManager.LoadScene(targetSceneName);&#10;            }&#10;            else&#10;            {&#10;                Debug.LogError(&quot;Target scene name is not set.&quot;);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Projects/Inventory/Inventory.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Projects/Inventory/Inventory.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;using System;&#10;&#10;public class Inventory : MonoBehaviour&#10;{&#10;    [Header(&quot;Inventory Settings&quot;)]&#10;    [SerializeField] private int inventorySize = 20;&#10;    [SerializeField] private InventorySlot[] slots;&#10;    &#10;    public static event Action&lt;InventorySlot[]&gt; OnInventoryChanged;&#10;    &#10;    private void Awake()&#10;    {&#10;        InitializeInventory();&#10;    }&#10;    &#10;    private void InitializeInventory()&#10;    {&#10;        // slots = new InventorySlot[inventorySize];&#10;        // for (int i = 0; i &lt; inventorySize; i++)&#10;        // {&#10;        //     slots[i] = new InventorySlot();&#10;        // }&#10;    }&#10;    &#10;    public bool AddItem(Item item, int quantity = 1)&#10;    {&#10;        if (item == null) return false;&#10;        &#10;        int remainingQuantity = quantity;&#10;        &#10;        // Сначала пытаемся добавить в существующие стаки&#10;        if (item.isStackable)&#10;        {&#10;            for (int i = 0; i &lt; slots.Length &amp;&amp; remainingQuantity &gt; 0; i++)&#10;            {&#10;                if (slots[i].CanAddItem(item))&#10;                {&#10;                    remainingQuantity = slots[i].AddItem(item, remainingQuantity);&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Затем создаем новые стаки в пустых слотах&#10;        for (int i = 0; i &lt; slots.Length &amp;&amp; remainingQuantity &gt; 0; i++)&#10;        {&#10;            if (slots[i].IsEmpty())&#10;            {&#10;                remainingQuantity = slots[i].AddItem(item, remainingQuantity);&#10;            }&#10;        }&#10;        &#10;        OnInventoryChanged?.Invoke(slots);&#10;        return remainingQuantity == 0;&#10;    }&#10;    &#10;    public bool RemoveItem(Item item, int quantity = 1)&#10;    {&#10;        if (item == null) return false;&#10;        &#10;        int remainingToRemove = quantity;&#10;        &#10;        for (int i = 0; i &lt; slots.Length &amp;&amp; remainingToRemove &gt; 0; i++)&#10;        {&#10;            if (slots[i].item == item)&#10;            {&#10;                int amountToRemove = Mathf.Min(remainingToRemove, slots[i].quantity);&#10;                slots[i].RemoveItem(amountToRemove);&#10;                remainingToRemove -= amountToRemove;&#10;            }&#10;        }&#10;        &#10;        OnInventoryChanged?.Invoke(slots);&#10;        return remainingToRemove == 0;&#10;    }&#10;    &#10;    public bool UseItem(int slotIndex, PetStats petStats)&#10;    {&#10;        if (slotIndex &lt; 0 || slotIndex &gt;= slots.Length) return false;&#10;        &#10;        InventorySlot slot = slots[slotIndex];&#10;        if (slot.IsEmpty()) return false;&#10;        &#10;        slot.item.UseItem(petStats);&#10;        slot.RemoveItem(1);&#10;        &#10;        OnInventoryChanged?.Invoke(slots);&#10;        return true;&#10;    }&#10;    &#10;    public int GetItemCount(Item item)&#10;    {&#10;        int count = 0;&#10;        for (int i = 0; i &lt; slots.Length; i++)&#10;        {&#10;            if (slots[i].item == item)&#10;            {&#10;                count += slots[i].quantity;&#10;            }&#10;        }&#10;        return count;&#10;    }&#10;    &#10;    public InventorySlot[] GetSlots()&#10;    {&#10;        return slots;&#10;    }&#10;    &#10;    public InventorySlot GetSlot(int index)&#10;    {&#10;        if (index &gt;= 0 &amp;&amp; index &lt; slots.Length)&#10;            return slots[index];&#10;        return null;&#10;    }&#10;    &#10;    public bool HasSpace()&#10;    {&#10;        for (int i = 0; i &lt; slots.Length; i++)&#10;        {&#10;            if (slots[i].IsEmpty()) return true;&#10;        }&#10;        return false;&#10;    }&#10;    &#10;    public void ClearInventory()&#10;    {&#10;        for (int i = 0; i &lt; slots.Length; i++)&#10;        {&#10;            slots[i].ClearSlot();&#10;        }&#10;        OnInventoryChanged?.Invoke(slots);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;using System;&#10;&#10;[System.Serializable]&#10;public class InventoryData&#10;{&#10;    public List&lt;SlotData&gt; slotData;&#10;    &#10;    public InventoryData()&#10;    {&#10;        slotData = new List&lt;SlotData&gt;();&#10;    }&#10;}&#10;&#10;[System.Serializable]&#10;public class SlotData&#10;{&#10;    public string itemName;&#10;    public int quantity;&#10;    &#10;    public SlotData(string itemName, int quantity)&#10;    {&#10;        this.itemName = itemName;&#10;        this.quantity = quantity;&#10;    }&#10;}&#10;&#10;public class Inventory : MonoBehaviour&#10;{&#10;    [Header(&quot;Inventory Settings&quot;)]&#10;    [SerializeField] private int inventorySize = 20;&#10;    [SerializeField] private InventorySlot[] slots;&#10;    &#10;    private const string INVENTORY_SAVE_KEY = &quot;PlayerInventory&quot;;&#10;    &#10;    public static event Action&lt;InventorySlot[]&gt; OnInventoryChanged;&#10;    &#10;    private void Awake()&#10;    {&#10;        InitializeInventory();&#10;        LoadInventory(); // Автоматически загружаем инвентарь при запуске&#10;    }&#10;    &#10;    private void InitializeInventory()&#10;    {&#10;        if (slots == null || slots.Length == 0)&#10;        {&#10;            slots = new InventorySlot[inventorySize];&#10;            for (int i = 0; i &lt; inventorySize; i++)&#10;            {&#10;                slots[i] = new InventorySlot();&#10;            }&#10;        }&#10;    }&#10;    &#10;    public bool AddItem(Item item, int quantity = 1)&#10;    {&#10;        if (item == null) return false;&#10;        &#10;        int remainingQuantity = quantity;&#10;        &#10;        // Сначала пытаемся добавить в существующие стаки&#10;        if (item.isStackable)&#10;        {&#10;            for (int i = 0; i &lt; slots.Length &amp;&amp; remainingQuantity &gt; 0; i++)&#10;            {&#10;                if (slots[i].CanAddItem(item))&#10;                {&#10;                    remainingQuantity = slots[i].AddItem(item, remainingQuantity);&#10;                }&#10;            }&#10;        }&#10;        &#10;        // Затем создаем новые стаки в пустых слотах&#10;        for (int i = 0; i &lt; slots.Length &amp;&amp; remainingQuantity &gt; 0; i++)&#10;        {&#10;            if (slots[i].IsEmpty())&#10;            {&#10;                remainingQuantity = slots[i].AddItem(item, remainingQuantity);&#10;            }&#10;        }&#10;        &#10;        SaveInventory(); // Автоматически сохраняем после изменения&#10;        OnInventoryChanged?.Invoke(slots);&#10;        return remainingQuantity == 0;&#10;    }&#10;    &#10;    public bool RemoveItem(Item item, int quantity = 1)&#10;    {&#10;        if (item == null) return false;&#10;        &#10;        int remainingToRemove = quantity;&#10;        &#10;        for (int i = 0; i &lt; slots.Length &amp;&amp; remainingToRemove &gt; 0; i++)&#10;        {&#10;            if (slots[i].item == item)&#10;            {&#10;                int amountToRemove = Mathf.Min(remainingToRemove, slots[i].quantity);&#10;                slots[i].RemoveItem(amountToRemove);&#10;                remainingToRemove -= amountToRemove;&#10;            }&#10;        }&#10;        &#10;        OnInventoryChanged?.Invoke(slots);&#10;        return remainingToRemove == 0;&#10;    }&#10;    &#10;    public bool UseItem(int slotIndex, PetStats petStats)&#10;    {&#10;        if (slotIndex &lt; 0 || slotIndex &gt;= slots.Length) return false;&#10;        &#10;        InventorySlot slot = slots[slotIndex];&#10;        if (slot.IsEmpty()) return false;&#10;        &#10;        slot.item.UseItem(petStats);&#10;        slot.RemoveItem(1);&#10;        &#10;        SaveInventory(); // Автоматически сохраняем после изменения&#10;        OnInventoryChanged?.Invoke(slots);&#10;        return true;&#10;    }&#10;    &#10;    public int GetItemCount(Item item)&#10;    {&#10;        int count = 0;&#10;        for (int i = 0; i &lt; slots.Length; i++)&#10;        {&#10;            if (slots[i].item == item)&#10;            {&#10;                count += slots[i].quantity;&#10;            }&#10;        }&#10;        return count;&#10;    }&#10;    &#10;    public InventorySlot[] GetSlots()&#10;    {&#10;        return slots;&#10;    }&#10;    &#10;    public InventorySlot GetSlot(int index)&#10;    {&#10;        if (index &gt;= 0 &amp;&amp; index &lt; slots.Length)&#10;            return slots[index];&#10;        return null;&#10;    }&#10;    &#10;    public bool HasSpace()&#10;    {&#10;        for (int i = 0; i &lt; slots.Length; i++)&#10;        {&#10;            if (slots[i].IsEmpty()) return true;&#10;        }&#10;        return false;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Сохраняет инвентарь в PlayerPrefs&#10;    /// &lt;/summary&gt;&#10;    public void SaveInventory()&#10;    {&#10;        InventoryData inventoryData = new InventoryData();&#10;        &#10;        for (int i = 0; i &lt; slots.Length; i++)&#10;        {&#10;            if (!slots[i].IsEmpty())&#10;            {&#10;                SlotData slotData = new SlotData(slots[i].item.name, slots[i].quantity);&#10;                inventoryData.slotData.Add(slotData);&#10;            }&#10;            else&#10;            {&#10;                // Добавляем пустой слот для сохранения позиций&#10;                SlotData emptySlot = new SlotData(&quot;&quot;, 0);&#10;                inventoryData.slotData.Add(emptySlot);&#10;            }&#10;        }&#10;        &#10;        string jsonData = JsonUtility.ToJson(inventoryData);&#10;        PlayerPrefs.SetString(INVENTORY_SAVE_KEY, jsonData);&#10;        PlayerPrefs.Save();&#10;        &#10;        Debug.Log(&quot;Инвентарь сохранен&quot;);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Загружает инвентарь из PlayerPrefs&#10;    /// &lt;/summary&gt;&#10;    public void LoadInventory()&#10;    {&#10;        if (!PlayerPrefs.HasKey(INVENTORY_SAVE_KEY))&#10;        {&#10;            Debug.Log(&quot;Сохраненный инвентарь не найден&quot;);&#10;            return;&#10;        }&#10;        &#10;        string jsonData = PlayerPrefs.GetString(INVENTORY_SAVE_KEY);&#10;        InventoryData inventoryData = JsonUtility.FromJson&lt;InventoryData&gt;(jsonData);&#10;        &#10;        if (inventoryData == null || inventoryData.slotData == null)&#10;        {&#10;            Debug.LogWarning(&quot;Не удалось загрузить данные инвентаря&quot;);&#10;            return;&#10;        }&#10;        &#10;        // Очищаем текущий инвентарь&#10;        for (int i = 0; i &lt; slots.Length; i++)&#10;        {&#10;            slots[i].ClearSlot();&#10;        }&#10;        &#10;        // Загружаем сохраненные данные&#10;        for (int i = 0; i &lt; inventoryData.slotData.Count &amp;&amp; i &lt; slots.Length; i++)&#10;        {&#10;            SlotData slotData = inventoryData.slotData[i];&#10;            &#10;            if (!string.IsNullOrEmpty(slotData.itemName) &amp;&amp; slotData.quantity &gt; 0)&#10;            {&#10;                Item item = LoadItemByName(slotData.itemName);&#10;                if (item != null)&#10;                {&#10;                    slots[i].AddItem(item, slotData.quantity);&#10;                }&#10;            }&#10;        }&#10;        &#10;        OnInventoryChanged?.Invoke(slots);&#10;        Debug.Log(&quot;Инвентарь загружен&quot;);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Загружает предмет по имени из Resources&#10;    /// &lt;/summary&gt;&#10;    private Item LoadItemByName(string itemName)&#10;    {&#10;        Item item = Resources.Load&lt;Item&gt;(itemName);&#10;        if (item == null)&#10;        {&#10;            // Пытаемся найти в корне Assets&#10;            item = Resources.Load&lt;Item&gt;(&quot;Items/&quot; + itemName);&#10;        }&#10;        &#10;        if (item == null)&#10;        {&#10;            Debug.LogWarning($&quot;Не удалось найти предмет: {itemName}&quot;);&#10;        }&#10;        &#10;        return item;&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Очищает сохраненный инвентарь&#10;    /// &lt;/summary&gt;&#10;    public void ClearSavedInventory()&#10;    {&#10;        PlayerPrefs.DeleteKey(INVENTORY_SAVE_KEY);&#10;        PlayerPrefs.Save();&#10;        Debug.Log(&quot;Сохраненный инвентарь очищен&quot;);&#10;    }&#10;    &#10;    /// &lt;summary&gt;&#10;    /// Очищает весь инвентарь&#10;    /// &lt;/summary&gt;&#10;    public void ClearInventory()&#10;    {&#10;        for (int i = 0; i &lt; slots.Length; i++)&#10;        {&#10;            slots[i].ClearSlot();&#10;        }&#10;        &#10;        SaveInventory();&#10;        OnInventoryChanged?.Invoke(slots);&#10;        Debug.Log(&quot;Инвентарь очищен&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Projects/InventoryController.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Projects/InventoryController.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;public class InventoryController : MonoBehaviour&#10;{&#10;    [Header(&quot;Input Settings&quot;)]&#10;    [SerializeField] private KeyCode inventoryKey = KeyCode.I;&#10;    &#10;    [Header(&quot;References&quot;)]&#10;    [SerializeField] private InventoryUI inventoryUI;&#10;    &#10;    private void Update()&#10;    {&#10;        if (Input.GetKeyDown(inventoryKey))&#10;        {&#10;            if (inventoryUI != null)&#10;            {&#10;                inventoryUI.ToggleInventory();&#10;            }&#10;        }&#10;    }&#10;    &#10;    // Публичные методы для добавления предметов (например, для тестирования или других систем)&#10;    public void AddTestItems()&#10;    {&#10;        if (inventoryUI != null)&#10;        {&#10;            // Эти методы можно использовать для тестирования после создания ScriptableObject предметов&#10;            Debug.Log(&quot;Добавьте предметы через ScriptableObject и вызовите inventoryUI.AddItem()&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Projects/InventorySlot.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Projects/InventorySlot.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;[System.Serializable]&#10;public class InventorySlot&#10;{&#10;    public Item item;&#10;    public int quantity;&#10;&#10;    public InventorySlot()&#10;    {&#10;        item = null;&#10;        quantity = 0;&#10;    }&#10;&#10;    public InventorySlot(Item newItem, int newQuantity)&#10;    {&#10;        item = newItem;&#10;        quantity = newQuantity;&#10;    }&#10;&#10;    public bool IsEmpty()&#10;    {&#10;        return item == null || quantity &lt;= 0;&#10;    }&#10;&#10;    public bool CanAddItem(Item itemToAdd)&#10;    {&#10;        if (IsEmpty()) return true;&#10;        return item == itemToAdd &amp;&amp; item.isStackable &amp;&amp; quantity &lt; item.maxStackSize;&#10;    }&#10;&#10;    public int AddItem(Item itemToAdd, int quantityToAdd)&#10;    {&#10;        if (IsEmpty())&#10;        {&#10;            item = itemToAdd;&#10;            quantity = quantityToAdd;&#10;            return 0;&#10;        }&#10;&#10;        if (item == itemToAdd &amp;&amp; item.isStackable)&#10;        {&#10;            int spaceLeft = item.maxStackSize - quantity;&#10;            int amountToAdd = Mathf.Min(quantityToAdd, spaceLeft);&#10;            quantity += amountToAdd;&#10;            return quantityToAdd - amountToAdd;&#10;        }&#10;&#10;        return quantityToAdd;&#10;    }&#10;&#10;    public void RemoveItem(int quantityToRemove)&#10;    {&#10;        quantity -= quantityToRemove;&#10;        if (quantity &lt;= 0)&#10;        {&#10;            item = null;&#10;            quantity = 0;&#10;        }&#10;    }&#10;&#10;    public void ClearSlot()&#10;    {&#10;        item = null;&#10;        quantity = 0;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Projects/InventoryUI.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Projects/InventoryUI.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;&#10;public class InventoryUI : MonoBehaviour&#10;{&#10;    [Header(&quot;UI References&quot;)]&#10;    [SerializeField] private Transform slotsParent;&#10;    [SerializeField] private GameObject slotPrefab;&#10;    [SerializeField] private Button closeButton;&#10;    &#10;    [Header(&quot;Components&quot;)]&#10;    [SerializeField] private Inventory inventory;&#10;    [SerializeField] private PetStats petStats;&#10;    &#10;    private ItemDisplay[] itemDisplays;&#10;    private bool isInitialized = false;&#10;    &#10;    private void Awake()&#10;    {&#10;        if (closeButton != null)&#10;        {&#10;            closeButton.onClick.AddListener(CloseInventory);&#10;        }&#10;    }&#10;    &#10;    private void OnEnable()&#10;    {&#10;        if (!isInitialized)&#10;        {&#10;            InitializeUI();&#10;        }&#10;        &#10;        Inventory.OnInventoryChanged += UpdateUI;&#10;        RefreshInventory();&#10;    }&#10;    &#10;    private void OnDisable()&#10;    {&#10;        Inventory.OnInventoryChanged -= UpdateUI;&#10;    }&#10;    &#10;    private void InitializeUI()&#10;    {&#10;        if (inventory == null)&#10;        {&#10;            Debug.LogError(&quot;Inventory не назначен в InventoryUI!&quot;);&#10;            return;&#10;        }&#10;        &#10;        InventorySlot[] slots = inventory.GetSlots();&#10;        itemDisplays = new ItemDisplay[slots.Length];&#10;        &#10;        // Создаем UI элементы для каждого слота&#10;        for (int i = 0; i &lt; slots.Length; i++)&#10;        {&#10;            GameObject slotObject;&#10;            &#10;            if (slotPrefab != null &amp;&amp; slotsParent != null)&#10;            {&#10;                slotObject = Instantiate(slotPrefab, slotsParent);&#10;            }&#10;            else&#10;            {&#10;                // Если префаб не назначен, создаем простой слот&#10;                slotObject = CreateSimpleSlot(i);&#10;            }&#10;            &#10;            ItemDisplay itemDisplay = slotObject.GetComponent&lt;ItemDisplay&gt;();&#10;            if (itemDisplay == null)&#10;            {&#10;                itemDisplay = slotObject.AddComponent&lt;ItemDisplay&gt;();&#10;            }&#10;            &#10;            itemDisplay.Initialize(this, i);&#10;            itemDisplays[i] = itemDisplay;&#10;        }&#10;        &#10;        isInitialized = true;&#10;    }&#10;    &#10;    private GameObject CreateSimpleSlot(int index)&#10;    {&#10;        GameObject slotObject = new GameObject($&quot;Slot_{index}&quot;);&#10;        slotObject.transform.SetParent(slotsParent);&#10;        &#10;        // Добавляем Image компонент для фона слота&#10;        Image slotBackground = slotObject.AddComponent&lt;Image&gt;();&#10;        slotBackground.color = new Color(0.2f, 0.2f, 0.2f, 0.8f);&#10;        &#10;        // Создаем дочерний объект для иконки предмета&#10;        GameObject iconObject = new GameObject(&quot;Icon&quot;);&#10;        iconObject.transform.SetParent(slotObject.transform);&#10;        Image iconImage = iconObject.AddComponent&lt;Image&gt;();&#10;        &#10;        // Создаем дочерний объект для текста количества&#10;        GameObject textObject = new GameObject(&quot;Quantity&quot;);&#10;        textObject.transform.SetParent(slotObject.transform);&#10;        &#10;        return slotObject;&#10;    }&#10;    &#10;    private void UpdateUI(InventorySlot[] slots)&#10;    {&#10;        RefreshInventory();&#10;    }&#10;    &#10;    public void RefreshInventory()&#10;    {&#10;        if (!isInitialized || inventory == null) return;&#10;        &#10;        InventorySlot[] slots = inventory.GetSlots();&#10;        &#10;        for (int i = 0; i &lt; itemDisplays.Length &amp;&amp; i &lt; slots.Length; i++)&#10;        {&#10;            if (itemDisplays[i] != null)&#10;            {&#10;                itemDisplays[i].UpdateDisplay(slots[i]);&#10;            }&#10;        }&#10;    }&#10;    &#10;    public void UseItem(int slotIndex)&#10;    {&#10;        if (inventory != null &amp;&amp; petStats != null)&#10;        {&#10;            bool success = inventory.UseItem(slotIndex, petStats);&#10;            if (success)&#10;            {&#10;                Debug.Log($&quot;Предмет из слота {slotIndex} использован!&quot;);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            Debug.LogError(&quot;Inventory или PetStats не назначены!&quot;);&#10;        }&#10;    }&#10;    &#10;    public void OpenInventory()&#10;    {&#10;        gameObject.SetActive(true);&#10;        RefreshInventory();&#10;    }&#10;    &#10;    public void CloseInventory()&#10;    {&#10;        gameObject.SetActive(false);&#10;    }&#10;    &#10;    public void ToggleInventory()&#10;    {&#10;        if (gameObject.activeInHierarchy)&#10;        {&#10;            CloseInventory();&#10;        }&#10;        else&#10;        {&#10;            OpenInventory();&#10;        }&#10;    }&#10;    &#10;    // Публичные методы для добавления предметов (например, для системы магазина или подбора предметов)&#10;    public bool AddItem(Item item, int quantity = 1)&#10;    {&#10;        if (inventory != null)&#10;        {&#10;            return inventory.AddItem(item, quantity);&#10;        }&#10;        return false;&#10;    }&#10;    &#10;    public int GetItemCount(Item item)&#10;    {&#10;        if (inventory != null)&#10;        {&#10;            return inventory.GetItemCount(item);&#10;        }&#10;        return 0;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Projects/Item.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Projects/Item.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;[System.Serializable]&#10;public enum ItemType&#10;{&#10;    Food,&#10;    Drink,&#10;    Toy,&#10;    Medicine,&#10;    Cleaning&#10;}&#10;&#10;[CreateAssetMenu(fileName = &quot;New Item&quot;, menuName = &quot;Inventory/Item&quot;)]&#10;public class Item : ScriptableObject&#10;{&#10;    [Header(&quot;Basic Info&quot;)]&#10;    public string itemName;&#10;    [TextArea(2, 5)]&#10;    public string description;&#10;    public Sprite icon;&#10;    public ItemType itemType;&#10;    &#10;    [Header(&quot;Stats&quot;)]&#10;    public int hungerRestore = 0;&#10;    public int thirstRestore = 0;&#10;    public int cleanlinessRestore = 0;&#10;    public int energyRestore = 0;&#10;    &#10;    [Header(&quot;Item Properties&quot;)]&#10;    public bool isStackable = true;&#10;    public int maxStackSize = 99;&#10;    public int value = 1;&#10;    &#10;    public virtual void UseItem(PetStats petStats)&#10;    {&#10;        if (petStats != null)&#10;        {&#10;            petStats.ModifyStats(hungerRestore, thirstRestore, cleanlinessRestore, energyRestore);&#10;            Debug.Log($&quot;Used {itemName}. Stats modified.&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Projects/PetStatsNotification.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Projects/PetStatsNotification.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using TMPro;&#10;using System.Collections;&#10;&#10;public class PetStatsNotification : MonoBehaviour&#10;{&#10;    [Header(&quot;Notification UI&quot;)]&#10;    [SerializeField] private GameObject notificationPanel;&#10;    [SerializeField] private TextMeshProUGUI notificationText;&#10;    [SerializeField] private Image notificationIcon;&#10;    [SerializeField] private Button closeButton;&#10;    &#10;    [Header(&quot;Notification Settings&quot;)]&#10;    [SerializeField] private float notificationDuration = 3f;&#10;    [SerializeField] private bool autoCloseNotifications = true;&#10;    &#10;    [Header(&quot;Icons&quot;)]&#10;    [SerializeField] private Sprite hungerIcon;&#10;    [SerializeField] private Sprite thirstIcon;&#10;    [SerializeField] private Sprite cleanlinessIcon;&#10;    [SerializeField] private Sprite sleepIcon;&#10;    &#10;    [Header(&quot;Colors&quot;)]&#10;    [SerializeField] private Color criticalColor = Color.red;&#10;    [SerializeField] private Color improvedColor = Color.green;&#10;    &#10;    private Coroutine currentNotificationCoroutine;&#10;    &#10;    private void OnEnable()&#10;    {&#10;        PetStatsUI.OnCriticalStat += ShowCriticalNotification;&#10;        PetStatsUI.OnStatImproved += ShowImprovedNotification;&#10;    }&#10;    &#10;    private void OnDisable()&#10;    {&#10;        PetStatsUI.OnCriticalStat -= ShowCriticalNotification;&#10;        PetStatsUI.OnStatImproved -= ShowImprovedNotification;&#10;    }&#10;    &#10;    private void Start()&#10;    {&#10;        if (notificationPanel != null)&#10;            notificationPanel.SetActive(false);&#10;            &#10;        if (closeButton != null)&#10;            closeButton.onClick.AddListener(CloseNotification);&#10;    }&#10;    &#10;    private void ShowCriticalNotification(PetStatsUI.StatType statType)&#10;    {&#10;        string message = GetCriticalMessage(statType);&#10;        Sprite icon = GetStatIcon(statType);&#10;        ShowNotification(message, icon, criticalColor);&#10;    }&#10;    &#10;    private void ShowImprovedNotification(PetStatsUI.StatType statType)&#10;    {&#10;        string message = GetImprovedMessage(statType);&#10;        Sprite icon = GetStatIcon(statType);&#10;        ShowNotification(message, icon, improvedColor);&#10;    }&#10;    &#10;    private void ShowNotification(string message, Sprite icon, Color color)&#10;    {&#10;        if (notificationPanel == null) return;&#10;        &#10;        // Останавливаем предыдущее уведомление&#10;        if (currentNotificationCoroutine != null)&#10;        {&#10;            StopCoroutine(currentNotificationCoroutine);&#10;        }&#10;        &#10;        // Настраиваем уведомление&#10;        if (notificationText != null)&#10;        {&#10;            notificationText.text = message;&#10;            notificationText.color = color;&#10;        }&#10;        &#10;        if (notificationIcon != null &amp;&amp; icon != null)&#10;        {&#10;            notificationIcon.sprite = icon;&#10;            notificationIcon.color = color;&#10;        }&#10;        &#10;        // Показываем уведомление&#10;        notificationPanel.SetActive(true);&#10;        &#10;        // Автоматически скрываем через время&#10;        if (autoCloseNotifications)&#10;        {&#10;            currentNotificationCoroutine = StartCoroutine(HideNotificationAfterDelay());&#10;        }&#10;    }&#10;    &#10;    private IEnumerator HideNotificationAfterDelay()&#10;    {&#10;        yield return new WaitForSeconds(notificationDuration);&#10;        CloseNotification();&#10;    }&#10;    &#10;    private void CloseNotification()&#10;    {&#10;        if (currentNotificationCoroutine != null)&#10;        {&#10;            StopCoroutine(currentNotificationCoroutine);&#10;            currentNotificationCoroutine = null;&#10;        }&#10;        &#10;        if (notificationPanel != null)&#10;            notificationPanel.SetActive(false);&#10;    }&#10;    &#10;    private string GetCriticalMessage(PetStatsUI.StatType statType)&#10;    {&#10;        switch (statType)&#10;        {&#10;            case PetStatsUI.StatType.Hunger:&#10;                return &quot;⚠️ Питомец очень голоден!\nПора покормить!&quot;;&#10;            case PetStatsUI.StatType.Thirst:&#10;                return &quot;⚠️ Питомец хочет пить!\nДайте воды!&quot;;&#10;            case PetStatsUI.StatType.Cleanliness:&#10;                return &quot;⚠️ Питомец грязный!\nПора помыть!&quot;;&#10;            case PetStatsUI.StatType.Sleep:&#10;                return &quot;⚠️ Питомец устал!\nНужен отдых!&quot;;&#10;            default:&#10;                return &quot;⚠️ Внимание требуется!&quot;;&#10;        }&#10;    }&#10;    &#10;    private string GetImprovedMessage(PetStatsUI.StatType statType)&#10;    {&#10;        switch (statType)&#10;        {&#10;            case PetStatsUI.StatType.Hunger:&#10;                return &quot;✅ Голод утолен!\nПитомец доволен!&quot;;&#10;            case PetStatsUI.StatType.Thirst:&#10;                return &quot;✅ Жажда утолена!\nПитомец освежился!&quot;;&#10;            case PetStatsUI.StatType.Cleanliness:&#10;                return &quot;✅ Питомец чистый!\nОн выглядит отлично!&quot;;&#10;            case PetStatsUI.StatType.Sleep:&#10;                return &quot;✅ Питомец отдохнул!\nЭнергия восстановлена!&quot;;&#10;            default:&#10;                return &quot;✅ Состояние улучшено!&quot;;&#10;        }&#10;    }&#10;    &#10;    private Sprite GetStatIcon(PetStatsUI.StatType statType)&#10;    {&#10;        switch (statType)&#10;        {&#10;            case PetStatsUI.StatType.Hunger:&#10;                return hungerIcon;&#10;            case PetStatsUI.StatType.Thirst:&#10;                return thirstIcon;&#10;            case PetStatsUI.StatType.Cleanliness:&#10;                return cleanlinessIcon;&#10;            case PetStatsUI.StatType.Sleep:&#10;                return sleepIcon;&#10;            default:&#10;                return null;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using TMPro;&#10;using System.Collections;&#10;&#10;namespace Projects&#10;{&#10;    public class PetStatsNotification : MonoBehaviour&#10;    {&#10;        [Header(&quot;Notification UI&quot;)]&#10;        [SerializeField] private GameObject notificationPanel;&#10;        [SerializeField] private TextMeshProUGUI notificationText;&#10;        [SerializeField] private Image notificationIcon;&#10;        [SerializeField] private Button closeButton;&#10;        &#10;        [Header(&quot;Notification Settings&quot;)]&#10;        [SerializeField] private float notificationDuration = 3f;&#10;        [SerializeField] private bool autoCloseNotifications = true;&#10;        &#10;        [Header(&quot;Icons&quot;)]&#10;        [SerializeField] private Sprite hungerIcon;&#10;        [SerializeField] private Sprite thirstIcon;&#10;        [SerializeField] private Sprite cleanlinessIcon;&#10;        [SerializeField] private Sprite sleepIcon;&#10;        &#10;        [Header(&quot;Colors&quot;)]&#10;        [SerializeField] private Color criticalColor = Color.red;&#10;        [SerializeField] private Color improvedColor = Color.green;&#10;        &#10;        private Coroutine _currentNotificationCoroutine;&#10;        &#10;        private void OnEnable()&#10;        {&#10;            PetStatsUI.OnCriticalStat += ShowCriticalNotification;&#10;            PetStatsUI.OnStatImproved += ShowImprovedNotification;&#10;        }&#10;        &#10;        private void OnDisable()&#10;        {&#10;            PetStatsUI.OnCriticalStat -= ShowCriticalNotification;&#10;            PetStatsUI.OnStatImproved -= ShowImprovedNotification;&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            if (notificationPanel != null)&#10;                notificationPanel.SetActive(false);&#10;                &#10;            if (closeButton != null)&#10;                closeButton.onClick.AddListener(CloseNotification);&#10;        }&#10;        &#10;        private void ShowCriticalNotification(PetStatsUI.StatType statType)&#10;        {&#10;            string message = GetCriticalMessage(statType);&#10;            Sprite icon = GetStatIcon(statType);&#10;            ShowNotification(message, icon, criticalColor);&#10;        }&#10;        &#10;        private void ShowImprovedNotification(PetStatsUI.StatType statType)&#10;        {&#10;            string message = GetImprovedMessage(statType);&#10;            Sprite icon = GetStatIcon(statType);&#10;            ShowNotification(message, icon, improvedColor);&#10;        }&#10;        &#10;        private void ShowNotification(string message, Sprite icon, Color color)&#10;        {&#10;            if (notificationPanel == null) return;&#10;            &#10;            // Останавливаем предыдущее уведомление&#10;            if (_currentNotificationCoroutine != null)&#10;            {&#10;                StopCoroutine(_currentNotificationCoroutine);&#10;            }&#10;            &#10;            // Настраиваем уведомление&#10;            if (notificationText != null)&#10;            {&#10;                notificationText.text = message;&#10;                notificationText.color = color;&#10;            }&#10;            &#10;            if (notificationIcon != null &amp;&amp; icon != null)&#10;            {&#10;                notificationIcon.sprite = icon;&#10;                notificationIcon.color = color;&#10;            }&#10;            &#10;            // Показываем уведомление&#10;            notificationPanel.SetActive(true);&#10;            &#10;            // Автоматически скрываем через время&#10;            if (autoCloseNotifications)&#10;            {&#10;                _currentNotificationCoroutine = StartCoroutine(HideNotificationAfterDelay());&#10;            }&#10;        }&#10;        &#10;        private IEnumerator HideNotificationAfterDelay()&#10;        {&#10;            yield return new WaitForSeconds(notificationDuration);&#10;            CloseNotification();&#10;        }&#10;        &#10;        private void CloseNotification()&#10;        {&#10;            if (_currentNotificationCoroutine != null)&#10;            {&#10;                StopCoroutine(_currentNotificationCoroutine);&#10;                _currentNotificationCoroutine = null;&#10;            }&#10;            &#10;            if (notificationPanel != null)&#10;                notificationPanel.SetActive(false);&#10;        }&#10;        &#10;        private string GetCriticalMessage(PetStatsUI.StatType statType)&#10;        {&#10;            switch (statType)&#10;            {&#10;                case PetStatsUI.StatType.Hunger:&#10;                    return &quot;⚠️ Питомец очень голоден!\nПора покормить!&quot;;&#10;                case PetStatsUI.StatType.Thirst:&#10;                    return &quot;⚠️ Питомец хочет пить!\nДайте воды!&quot;;&#10;                case PetStatsUI.StatType.Cleanliness:&#10;                    return &quot;⚠️ Питомец грязный!\nПора помыть!&quot;;&#10;                case PetStatsUI.StatType.Sleep:&#10;                    return &quot;⚠️ Питомец устал!\nНужен отдых!&quot;;&#10;                default:&#10;                    return &quot;⚠️ Внимание требуется!&quot;;&#10;            }&#10;        }&#10;        &#10;        private string GetImprovedMessage(PetStatsUI.StatType statType)&#10;        {&#10;            switch (statType)&#10;            {&#10;                case PetStatsUI.StatType.Hunger:&#10;                    return &quot;✅ Голод утолен!\nПитомец доволен!&quot;;&#10;                case PetStatsUI.StatType.Thirst:&#10;                    return &quot;✅ Жажда утолена!\nПитомец освежился!&quot;;&#10;                case PetStatsUI.StatType.Cleanliness:&#10;                    return &quot;✅ Питомец чистый!\nОн выглядит отлично!&quot;;&#10;                case PetStatsUI.StatType.Sleep:&#10;                    return &quot;✅ Питомец отдохнул!\nЭнергия восстановлена!&quot;;&#10;                default:&#10;                    return &quot;✅ Состояние улучшено!&quot;;&#10;            }&#10;        }&#10;        &#10;        private Sprite GetStatIcon(PetStatsUI.StatType statType)&#10;        {&#10;            switch (statType)&#10;            {&#10;                case PetStatsUI.StatType.Hunger:&#10;                    return hungerIcon;&#10;                case PetStatsUI.StatType.Thirst:&#10;                    return thirstIcon;&#10;                case PetStatsUI.StatType.Cleanliness:&#10;                    return cleanlinessIcon;&#10;                case PetStatsUI.StatType.Sleep:&#10;                    return sleepIcon;&#10;                default:&#10;                    return null;&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Projects/Shop.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Projects/Shop.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using System.Collections.Generic;&#10;using System;&#10;&#10;public class Shop : MonoBehaviour&#10;{&#10;    [Header(&quot;Shop Settings&quot;)]&#10;    [SerializeField] private string shopName = &quot;Pet Shop&quot;;&#10;    [SerializeField] private List&lt;ShopItem&gt; shopItems = new List&lt;ShopItem&gt;();&#10;    &#10;    [Header(&quot;Dependencies&quot;)]&#10;    [SerializeField] private Inventory inventory;&#10;    [SerializeField] private PlayerCurrency playerCurrency;&#10;    &#10;    public static event Action&lt;ShopItem[]&gt; OnShopItemsChanged;&#10;    public static event Action&lt;string&gt; OnPurchaseResult;&#10;    &#10;    public ShopItem[] ShopItems =&gt; shopItems.ToArray();&#10;    public string ShopName =&gt; shopName;&#10;    &#10;    private void Awake()&#10;    {&#10;        if (inventory == null)&#10;            inventory = FindObjectOfType&lt;Inventory&gt;();&#10;        &#10;        if (playerCurrency == null)&#10;            playerCurrency = FindObjectOfType&lt;PlayerCurrency&gt;();&#10;    }&#10;    &#10;    private void Start()&#10;    {&#10;        OnShopItemsChanged?.Invoke(ShopItems);&#10;    }&#10;    &#10;    public bool PurchaseItem(int shopItemIndex, int quantity = 1)&#10;    {&#10;        if (shopItemIndex &lt; 0 || shopItemIndex &gt;= shopItems.Count)&#10;        {&#10;            OnPurchaseResult?.Invoke(&quot;Неверный товар!&quot;);&#10;            return false;&#10;        }&#10;        &#10;        ShopItem shopItem = shopItems[shopItemIndex];&#10;        &#10;        if (shopItem == null || shopItem.item == null)&#10;        {&#10;            OnPurchaseResult?.Invoke(&quot;Товар недоступен!&quot;);&#10;            return false;&#10;        }&#10;        &#10;        // Проверяем возможность покупки&#10;        if (!shopItem.CanPurchase(playerCurrency.CurrentMoney, quantity))&#10;        {&#10;            if (!shopItem.isAvailable)&#10;            {&#10;                OnPurchaseResult?.Invoke($&quot;{shopItem.item.itemName} закончился!&quot;);&#10;            }&#10;            else if (shopItem.stock != -1 &amp;&amp; shopItem.stock &lt; quantity)&#10;            {&#10;                OnPurchaseResult?.Invoke($&quot;В наличии только {shopItem.stock} шт. {shopItem.item.itemName}!&quot;);&#10;            }&#10;            else&#10;            {&#10;                OnPurchaseResult?.Invoke($&quot;Недостаточно денег! Нужно: {shopItem.price * quantity}&quot;);&#10;            }&#10;            return false;&#10;        }&#10;        &#10;        // Проверяем, поместится ли товар в инвентарь&#10;        if (!CanAddToInventory(shopItem.item, quantity))&#10;        {&#10;            OnPurchaseResult?.Invoke(&quot;Недостаточно места в инвентаре!&quot;);&#10;            return false;&#10;        }&#10;        &#10;        // Совершаем покупку&#10;        int totalCost = shopItem.price * quantity;&#10;        &#10;        if (playerCurrency.SpendMoney(totalCost))&#10;        {&#10;            // Добавляем товар в инвентарь&#10;            if (inventory.AddItem(shopItem.item, quantity))&#10;            {&#10;                // Уменьшаем запас товара в магазине&#10;                shopItem.Purchase(quantity);&#10;                &#10;                OnPurchaseResult?.Invoke($&quot;Куплено: {quantity} x {shopItem.item.itemName} за {totalCost} монет!&quot;);&#10;                OnShopItemsChanged?.Invoke(ShopItems);&#10;                return true;&#10;            }&#10;            else&#10;            {&#10;                // Возвращаем деньги, если не удалось добавить в инвентарь&#10;                playerCurrency.AddMoney(totalCost);&#10;                OnPurchaseResult?.Invoke(&quot;Не удалось добавить товар в инвентарь!&quot;);&#10;                return false;&#10;            }&#10;        }&#10;        &#10;        return false;&#10;    }&#10;    &#10;    private bool CanAddToInventory(Item item, int quantity)&#10;    {&#10;        if (inventory == null || item == null) return false;&#10;        &#10;        // Простая проверка - пытаемся добавить в инвентарь и смотрим результат&#10;        // Это не идеальное решение, но работает с текущей структурой инвентаря&#10;        return true; // Предполагаем, что AddItem в Inventory уже проверяет место&#10;    }&#10;    &#10;    public ShopItem GetShopItem(int index)&#10;    {&#10;        if (index &gt;= 0 &amp;&amp; index &lt; shopItems.Count)&#10;            return shopItems[index];&#10;        return null;&#10;    }&#10;    &#10;    public void AddShopItem(ShopItem newItem)&#10;    {&#10;        if (newItem != null &amp;&amp; newItem.item != null)&#10;        {&#10;            shopItems.Add(newItem);&#10;            OnShopItemsChanged?.Invoke(ShopItems);&#10;        }&#10;    }&#10;    &#10;    public void RemoveShopItem(int index)&#10;    {&#10;        if (index &gt;= 0 &amp;&amp; index &lt; shopItems.Count)&#10;        {&#10;            shopItems.RemoveAt(index);&#10;            OnShopItemsChanged?.Invoke(ShopItems);&#10;        }&#10;    }&#10;    &#10;    public void RestockItem(int index, int amount)&#10;    {&#10;        if (index &gt;= 0 &amp;&amp; index &lt; shopItems.Count)&#10;        {&#10;            shopItems[index].RestockItem(amount);&#10;            OnShopItemsChanged?.Invoke(ShopItems);&#10;        }&#10;    }&#10;    &#10;    public void RestockAllItems()&#10;    {&#10;        foreach (ShopItem shopItem in shopItems)&#10;        {&#10;            if (shopItem.stock != -1)&#10;            {&#10;                shopItem.RestockItem(10); // Пополняем на 10 единиц&#10;            }&#10;        }&#10;        OnShopItemsChanged?.Invoke(ShopItems);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Projects/ShopItem.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Projects/ShopItem.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;[System.Serializable]&#10;public class ShopItem&#10;{&#10;    [Header(&quot;Shop Item Info&quot;)]&#10;    public Item item;&#10;    public int price;&#10;    public int stock = -1; // -1 означает неограниченный запас&#10;    public bool isAvailable = true;&#10;    &#10;    [Header(&quot;Display&quot;)]&#10;    public Sprite shopIcon;&#10;    [TextArea(2, 3)]&#10;    public string shopDescription;&#10;    &#10;    public bool CanPurchase(int playerMoney, int quantity = 1)&#10;    {&#10;        if (!isAvailable || item == null) return false;&#10;        if (playerMoney &lt; price * quantity) return false;&#10;        if (stock != -1 &amp;&amp; stock &lt; quantity) return false;&#10;        &#10;        return true;&#10;    }&#10;    &#10;    public void Purchase(int quantity = 1)&#10;    {&#10;        if (stock != -1)&#10;        {&#10;            stock -= quantity;&#10;            if (stock &lt;= 0)&#10;            {&#10;                stock = 0;&#10;                isAvailable = false;&#10;            }&#10;        }&#10;    }&#10;    &#10;    public void RestockItem(int amount)&#10;    {&#10;        if (stock != -1)&#10;        {&#10;            stock += amount;&#10;            isAvailable = true;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Projects/ShopItemUI.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Projects/ShopItemUI.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using TMPro;&#10;&#10;public class ShopItemUI : MonoBehaviour&#10;{&#10;    [Header(&quot;UI Elements&quot;)]&#10;    [SerializeField] private Image itemIcon;&#10;    [SerializeField] private TextMeshProUGUI itemNameText;&#10;    [SerializeField] private TextMeshProUGUI itemDescriptionText;&#10;    [SerializeField] private TextMeshProUGUI priceText;&#10;    [SerializeField] private TextMeshProUGUI stockText;&#10;    [SerializeField] private Button purchaseButton;&#10;    [SerializeField] private GameObject soldOutOverlay;&#10;    &#10;    private ShopItem shopItem;&#10;    private Shop shop;&#10;    private int shopItemIndex;&#10;    &#10;    public void Initialize(ShopItem item, Shop shopReference, int index)&#10;    {&#10;        shopItem = item;&#10;        shop = shopReference;&#10;        shopItemIndex = index;&#10;        &#10;        UpdateDisplay();&#10;        &#10;        if (purchaseButton != null)&#10;        {&#10;            purchaseButton.onClick.RemoveAllListeners();&#10;            purchaseButton.onClick.AddListener(() =&gt; PurchaseItem());&#10;        }&#10;    }&#10;    &#10;    private void UpdateDisplay()&#10;    {&#10;        if (shopItem == null || shopItem.item == null) return;&#10;        &#10;        // Иконка товара&#10;        if (itemIcon != null)&#10;        {&#10;            Sprite iconToUse = shopItem.shopIcon != null ? shopItem.shopIcon : shopItem.item.icon;&#10;            itemIcon.sprite = iconToUse;&#10;        }&#10;        &#10;        // Название товара&#10;        if (itemNameText != null)&#10;        {&#10;            itemNameText.text = shopItem.item.itemName;&#10;        }&#10;        &#10;        // Описание товара&#10;        if (itemDescriptionText != null)&#10;        {&#10;            string description = !string.IsNullOrEmpty(shopItem.shopDescription) &#10;                ? shopItem.shopDescription &#10;                : shopItem.item.description;&#10;            itemDescriptionText.text = description;&#10;        }&#10;        &#10;        // Цена&#10;        if (priceText != null)&#10;        {&#10;            priceText.text = $&quot;{shopItem.price} монет&quot;;&#10;        }&#10;        &#10;        // Количество в наличии&#10;        if (stockText != null)&#10;        {&#10;            if (shopItem.stock == -1)&#10;            {&#10;                stockText.text = &quot;В наличии: ∞&quot;;&#10;            }&#10;            else&#10;            {&#10;                stockText.text = $&quot;В наличии: {shopItem.stock}&quot;;&#10;            }&#10;        }&#10;        &#10;        // Доступность покупки&#10;        bool canPurchase = shopItem.isAvailable &amp;&amp; shopItem.stock != 0;&#10;        &#10;        if (purchaseButton != null)&#10;        {&#10;            purchaseButton.interactable = canPurchase;&#10;        }&#10;        &#10;        if (soldOutOverlay != null)&#10;        {&#10;            soldOutOverlay.SetActive(!canPurchase);&#10;        }&#10;    }&#10;    &#10;    private void PurchaseItem()&#10;    {&#10;        if (shop != null)&#10;        {&#10;            shop.PurchaseItem(shopItemIndex, 1);&#10;            UpdateDisplay(); // Обновляем отображение после покупки&#10;        }&#10;    }&#10;    &#10;    public void RefreshDisplay()&#10;    {&#10;        UpdateDisplay();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Projects/ShopManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Projects/ShopManager.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;public class ShopManager : MonoBehaviour&#10;{&#10;    [Header(&quot;Shop Access&quot;)]&#10;    [SerializeField] private KeyCode openShopKey = KeyCode.S;&#10;    [SerializeField] private bool canOpenShop = true;&#10;    &#10;    [Header(&quot;Dependencies&quot;)]&#10;    private ShopUI shopUI;&#10;    private Shop shop;&#10;    &#10;    private void Awake()&#10;    {&#10;        shopUI = FindObjectOfType&lt;ShopUI&gt;();&#10;        shop = FindObjectOfType&lt;Shop&gt;();&#10;    }&#10;    &#10;    private void Update()&#10;    {&#10;        if (canOpenShop &amp;&amp; Input.GetKeyDown(openShopKey))&#10;        {&#10;            ToggleShop();&#10;        }&#10;    }&#10;    &#10;    public void OpenShop()&#10;    {&#10;        if (shopUI != null &amp;&amp; canOpenShop)&#10;        {&#10;            shopUI.OpenShop();&#10;        }&#10;    }&#10;    &#10;    public void CloseShop()&#10;    {&#10;        if (shopUI != null)&#10;        {&#10;            shopUI.CloseShop();&#10;        }&#10;    }&#10;    &#10;    public void ToggleShop()&#10;    {&#10;        if (shopUI != null &amp;&amp; shopUI.gameObject.activeInHierarchy)&#10;        {&#10;            bool isShopOpen = shopUI.transform.GetChild(0).gameObject.activeSelf; // Предполагаем, что shopPanel первый дочерний объект&#10;            &#10;            if (isShopOpen)&#10;                CloseShop();&#10;            else&#10;                OpenShop();&#10;        }&#10;        else&#10;        {&#10;            OpenShop();&#10;        }&#10;    }&#10;    &#10;    public void SetShopAccess(bool canAccess)&#10;    {&#10;        canOpenShop = canAccess;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Projects/ShopUI.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Projects/ShopUI.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using UnityEngine.UI;&#10;using TMPro;&#10;using System.Collections.Generic;&#10;&#10;public class ShopUI : MonoBehaviour&#10;{&#10;    [Header(&quot;UI References&quot;)]&#10;    [SerializeField] private GameObject shopPanel;&#10;    [SerializeField] private TextMeshProUGUI shopNameText;&#10;    [SerializeField] private TextMeshProUGUI playerMoneyText;&#10;    [SerializeField] private TextMeshProUGUI messageText;&#10;    [SerializeField] private Transform shopItemsContainer;&#10;    [SerializeField] private GameObject shopItemUIPrefab;&#10;    [SerializeField] private Button closeButton;&#10;    [SerializeField] private Button restockButton;&#10;    &#10;    [Header(&quot;Dependencies&quot;)]&#10;    [SerializeField] private Shop shop;&#10;    [SerializeField] private PlayerCurrency playerCurrency;&#10;    &#10;    private List&lt;ShopItemUI&gt; shopItemUIList = new List&lt;ShopItemUI&gt;();&#10;    &#10;    private void Awake()&#10;    {&#10;        if (shop == null)&#10;            shop = FindObjectOfType&lt;Shop&gt;();&#10;            &#10;        if (playerCurrency == null)&#10;            playerCurrency = FindObjectOfType&lt;PlayerCurrency&gt;();&#10;    }&#10;    &#10;    private void OnEnable()&#10;    {&#10;        Shop.OnShopItemsChanged += UpdateShopDisplay;&#10;        Shop.OnPurchaseResult += ShowMessage;&#10;        PlayerCurrency.OnMoneyChanged += UpdateMoneyDisplay;&#10;    }&#10;    &#10;    private void OnDisable()&#10;    {&#10;        Shop.OnShopItemsChanged -= UpdateShopDisplay;&#10;        Shop.OnPurchaseResult -= ShowMessage;&#10;        PlayerCurrency.OnMoneyChanged -= UpdateMoneyDisplay;&#10;    }&#10;    &#10;    private void Start()&#10;    {&#10;        InitializeUI();&#10;        &#10;        if (shopPanel != null)&#10;            shopPanel.SetActive(false);&#10;    }&#10;    &#10;    private void InitializeUI()&#10;    {&#10;        // Настройка кнопок&#10;        if (closeButton != null)&#10;        {&#10;            closeButton.onClick.AddListener(CloseShop);&#10;        }&#10;        &#10;        if (restockButton != null)&#10;        {&#10;            restockButton.onClick.AddListener(RestockAllItems);&#10;        }&#10;        &#10;        // Обновляем отображение&#10;        if (shop != null &amp;&amp; shopNameText != null)&#10;        {&#10;            shopNameText.text = shop.ShopName;&#10;        }&#10;        &#10;        UpdateMoneyDisplay(playerCurrency != null ? playerCurrency.CurrentMoney : 0);&#10;        ClearMessage();&#10;    }&#10;    &#10;    public void OpenShop()&#10;    {&#10;        if (shopPanel != null)&#10;        {&#10;            shopPanel.SetActive(true);&#10;            UpdateShopDisplay(shop.ShopItems);&#10;        }&#10;    }&#10;    &#10;    public void CloseShop()&#10;    {&#10;        if (shopPanel != null)&#10;        {&#10;            shopPanel.SetActive(false);&#10;        }&#10;    }&#10;    &#10;    private void UpdateShopDisplay(ShopItem[] shopItems)&#10;    {&#10;        // Очищаем старые элементы UI&#10;        ClearShopItems();&#10;        &#10;        if (shopItems == null || shopItemsContainer == null || shopItemUIPrefab == null)&#10;            return;&#10;        &#10;        // Создаем новые элементы UI для каждого товара&#10;        for (int i = 0; i &lt; shopItems.Length; i++)&#10;        {&#10;            GameObject itemUIObj = Instantiate(shopItemUIPrefab, shopItemsContainer);&#10;            ShopItemUI itemUI = itemUIObj.GetComponent&lt;ShopItemUI&gt;();&#10;            &#10;            if (itemUI != null)&#10;            {&#10;                itemUI.Initialize(shopItems[i], shop, i);&#10;                shopItemUIList.Add(itemUI);&#10;            }&#10;        }&#10;    }&#10;    &#10;    private void ClearShopItems()&#10;    {&#10;        foreach (ShopItemUI itemUI in shopItemUIList)&#10;        {&#10;            if (itemUI != null &amp;&amp; itemUI.gameObject != null)&#10;            {&#10;                Destroy(itemUI.gameObject);&#10;            }&#10;        }&#10;        shopItemUIList.Clear();&#10;    }&#10;    &#10;    private void UpdateMoneyDisplay(int currentMoney)&#10;    {&#10;        if (playerMoneyText != null)&#10;        {&#10;            playerMoneyText.text = $&quot;Монеты: {currentMoney}&quot;;&#10;        }&#10;    }&#10;    &#10;    private void ShowMessage(string message)&#10;    {&#10;        if (messageText != null)&#10;        {&#10;            messageText.text = message;&#10;            messageText.gameObject.SetActive(true);&#10;            &#10;            // Скрываем сообщение через 3 секунды&#10;            Invoke(nameof(ClearMessage), 3f);&#10;        }&#10;    }&#10;    &#10;    private void ClearMessage()&#10;    {&#10;        if (messageText != null)&#10;        {&#10;            messageText.text = &quot;&quot;;&#10;            messageText.gameObject.SetActive(false);&#10;        }&#10;    }&#10;    &#10;    private void RestockAllItems()&#10;    {&#10;        if (shop != null)&#10;        {&#10;            shop.RestockAllItems();&#10;            ShowMessage(&quot;Товары пополнены!&quot;);&#10;        }&#10;    }&#10;    &#10;    public void RefreshShopDisplay()&#10;    {&#10;        foreach (ShopItemUI itemUI in shopItemUIList)&#10;        {&#10;            if (itemUI != null)&#10;            {&#10;                itemUI.RefreshDisplay();&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Projects/TimeManager.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Projects/TimeManager.cs" />
              <option name="updatedContent" value="using UnityEngine;&#10;using System;&#10;&#10;public class TimeManager : MonoBehaviour&#10;{&#10;    private const string LastLoginKey = &quot;LastLoginTime&quot;;&#10;&#10;    public void SaveLastLoginTime()&#10;    {&#10;        DateTime now = DateTime.Now;&#10;        PlayerPrefs.SetString(LastLoginKey, now.ToString());&#10;        PlayerPrefs.Save();&#10;    }&#10;&#10;    public float GetTimeSinceLastLogin()&#10;    {&#10;        if (PlayerPrefs.HasKey(LastLoginKey))&#10;        {&#10;            string lastLoginString = PlayerPrefs.GetString(LastLoginKey);&#10;            if (DateTime.TryParse(lastLoginString, out DateTime lastLoginTime))&#10;            {&#10;                TimeSpan timeSinceLastLogin = DateTime.Now - lastLoginTime;&#10;                return (float)timeSinceLastLogin.TotalSeconds;&#10;            }&#10;        }&#10;&#10;        // If no last login time is found, return -1 to indicate first login&#10;        return -1f;&#10;    }&#10;&#10;    private void OnApplicationQuit()&#10;    {&#10;        SaveLastLoginTime();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Projects/Wallet.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Projects/Wallet.cs" />
              <option name="originalContent" value="using System;&#10;using UnityEngine;&#10;&#10;namespace Projects&#10;{&#10;    public class Wallet : MonoBehaviour&#10;    {&#10;        private static Wallet _instance;&#10;        &#10;        [Header(&quot;Wallet Settings&quot;)]&#10;        [SerializeField] private int currentMoney = 0;&#10;        [SerializeField] private string currencyName = &quot;Coins&quot;;&#10;        &#10;        public static Wallet Instance&#10;        {&#10;            get&#10;            {&#10;                if (_instance == null)&#10;                {&#10;                    _instance = FindObjectOfType&lt;Wallet&gt;();&#10;                    if (_instance == null)&#10;                    {&#10;                        GameObject walletObject = new GameObject(&quot;Wallet&quot;);&#10;                        _instance = walletObject.AddComponent&lt;Wallet&gt;();&#10;                        DontDestroyOnLoad(walletObject);&#10;                    }&#10;                }&#10;                return _instance;&#10;            }&#10;        }&#10;        &#10;        public string CurrencyName&#10;        {&#10;            get =&gt; currencyName;&#10;            set =&gt; currencyName = value;&#10;        }&#10;        &#10;        public static event Action&lt;int&gt; OnMoneyChanged;&#10;        &#10;        public int CurrentMoney =&gt; currentMoney;&#10;        &#10;        private void Awake()&#10;        {&#10;            if (_instance == null)&#10;            {&#10;                _instance = this;&#10;                DontDestroyOnLoad(gameObject);&#10;            }&#10;            else if (_instance != this)&#10;            {&#10;                Destroy(gameObject);&#10;            }&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            OnMoneyChanged?.Invoke(currentMoney);&#10;        }&#10;        &#10;        public bool CanAfford(int amount)&#10;        {&#10;            return currentMoney &gt;= amount;&#10;        }&#10;        &#10;        public bool SpendMoney(int amount)&#10;        {&#10;            if (!CanAfford(amount))&#10;            {&#10;                Debug.Log($&quot;Недостаточно {currencyName}! Нужно: {amount}  &lt;sprite index=2&gt;, есть: {currentMoney} &lt;sprite index=2&gt;&quot;);&#10;                return false;&#10;            }&#10;            &#10;            currentMoney -= amount;&#10;            OnMoneyChanged?.Invoke(currentMoney);&#10;            Debug.Log($&quot;Потрачено {amount} {currencyName}. Осталось: {currentMoney} &lt;sprite index=2&gt;&quot;);&#10;            return true;&#10;        }&#10;        &#10;        public void AddMoney(int amount)&#10;        {&#10;            if (amount &lt; 0)&#10;            {&#10;                Debug.LogWarning(&quot;Попытка добавить отрицательную сумму денег!&quot;);&#10;                return;&#10;            }&#10;            &#10;            currentMoney += amount;&#10;            OnMoneyChanged?.Invoke(currentMoney);&#10;            Debug.Log($&quot;Получено {amount} {currencyName}. Всего: {currentMoney} &lt;sprite index=2&gt;&quot;);&#10;        }&#10;        &#10;        public void SetMoney(int amount)&#10;        {&#10;            if (amount &lt; 0)&#10;            {&#10;                Debug.LogWarning(&quot;Попытка установить отрицательную сумму денег!&quot;);&#10;                amount = 0;&#10;            }&#10;            &#10;            currentMoney = amount;&#10;            OnMoneyChanged?.Invoke(currentMoney);&#10;            Debug.Log($&quot;Деньги установлены на: {currentMoney} &lt;sprite index=2&gt;&quot;);&#10;        }&#10;        &#10;        public void ResetMoney()&#10;        {&#10;            SetMoney(0);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using UnityEngine;&#10;&#10;namespace Projects&#10;{&#10;    public class Wallet : MonoBehaviour&#10;    {&#10;        private static Wallet _instance;&#10;        &#10;        [Header(&quot;Wallet Settings&quot;)]&#10;        [SerializeField] private int currentMoney = 0;&#10;        [SerializeField] private string currencyName = &quot;Coins&quot;;&#10;        &#10;        private const string MONEY_SAVE_KEY = &quot;PlayerMoney&quot;;&#10;        &#10;        public static Wallet Instance&#10;        {&#10;            get&#10;            {&#10;                if (_instance == null)&#10;                {&#10;                    _instance = FindObjectOfType&lt;Wallet&gt;();&#10;                    if (_instance == null)&#10;                    {&#10;                        GameObject walletObject = new GameObject(&quot;Wallet&quot;);&#10;                        _instance = walletObject.AddComponent&lt;Wallet&gt;();&#10;                        DontDestroyOnLoad(walletObject);&#10;                    }&#10;                }&#10;                return _instance;&#10;            }&#10;        }&#10;        &#10;        public string CurrencyName&#10;        {&#10;            get =&gt; currencyName;&#10;            set =&gt; currencyName = value;&#10;        }&#10;        &#10;        public static event Action&lt;int&gt; OnMoneyChanged;&#10;        &#10;        public int CurrentMoney =&gt; currentMoney;&#10;        &#10;        private void Awake()&#10;        {&#10;            if (_instance == null)&#10;            {&#10;                _instance = this;&#10;                DontDestroyOnLoad(gameObject);&#10;                LoadMoney(); // Автоматически загружаем деньги при запуске&#10;            }&#10;            else if (_instance != this)&#10;            {&#10;                Destroy(gameObject);&#10;            }&#10;        }&#10;        &#10;        private void Start()&#10;        {&#10;            OnMoneyChanged?.Invoke(currentMoney);&#10;        }&#10;        &#10;        public bool CanAfford(int amount)&#10;        {&#10;            return currentMoney &gt;= amount;&#10;        }&#10;        &#10;        public bool SpendMoney(int amount)&#10;        {&#10;            if (!CanAfford(amount))&#10;            {&#10;                Debug.Log($&quot;Недостаточно {currencyName}! Нужно: {amount}  &lt;sprite index=2&gt;, есть: {currentMoney} &lt;sprite index=2&gt;&quot;);&#10;                return false;&#10;            }&#10;            &#10;            currentMoney -= amount;&#10;            OnMoneyChanged?.Invoke(currentMoney);&#10;            Debug.Log($&quot;Потрачено {amount} {currencyName}. Осталось: {currentMoney} &lt;sprite index=2&gt;&quot;);&#10;            return true;&#10;        }&#10;        &#10;        public void AddMoney(int amount)&#10;        {&#10;            if (amount &lt; 0)&#10;            {&#10;                Debug.LogWarning(&quot;Попытка добавить отрицательную сумму денег!&quot;);&#10;                return;&#10;            }&#10;            &#10;            currentMoney += amount;&#10;            SaveMoney(); // Автоматически сохраняем после изменения&#10;            OnMoneyChanged?.Invoke(currentMoney);&#10;            Debug.Log($&quot;Получено {amount} {currencyName}. Всего: {currentMoney} &lt;sprite index=2&gt;&quot;);&#10;        }&#10;        &#10;        public void SetMoney(int amount)&#10;        {&#10;            if (amount &lt; 0)&#10;            {&#10;                Debug.LogWarning(&quot;Попытка установить отрицательную сумму денег!&quot;);&#10;                amount = 0;&#10;            }&#10;            &#10;            currentMoney = amount;&#10;            SaveMoney(); // Автоматически сохраняем после изменения&#10;            OnMoneyChanged?.Invoke(currentMoney);&#10;            Debug.Log($&quot;Деньги установлены на: {currentMoney} &lt;sprite index=2&gt;&quot;);&#10;        }&#10;        &#10;        public void ResetMoney()&#10;        {&#10;            SetMoney(0);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Сохраняет текущее количество денег в PlayerPrefs&#10;        /// &lt;/summary&gt;&#10;        public void SaveMoney()&#10;        {&#10;            PlayerPrefs.SetInt(MONEY_SAVE_KEY, currentMoney);&#10;            PlayerPrefs.Save();&#10;            Debug.Log($&quot;Деньги сохранены: {currentMoney} {currencyName}&quot;);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Загружает количество денег из PlayerPrefs&#10;        /// &lt;/summary&gt;&#10;        public void LoadMoney()&#10;        {&#10;            currentMoney = PlayerPrefs.GetInt(MONEY_SAVE_KEY, 0); // По умолчанию 0 денег&#10;            OnMoneyChanged?.Invoke(currentMoney);&#10;            Debug.Log($&quot;Деньги загружены: {currentMoney} {currencyName}&quot;);&#10;        }&#10;        &#10;        /// &lt;summary&gt;&#10;        /// Очищает сохраненные данные о деньгах&#10;        /// &lt;/summary&gt;&#10;        public void ClearSavedMoney()&#10;        {&#10;            PlayerPrefs.DeleteKey(MONEY_SAVE_KEY);&#10;            PlayerPrefs.Save();&#10;            Debug.Log(&quot;Сохраненные данные о деньгах очищены&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/LoaderView.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/LoaderView.cs" />
              <option name="originalContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;public class LoaderView : MonoBehaviour&#10;{&#10;    private Coroutine _loadingCoroutine;&#10;&#10;    private bool _canRotate;&#10;&#10;    private void OnEnable()&#10;    {&#10;        _loadingCoroutine = StartCoroutine(DelayLoading());&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        StopCoroutine(_loadingCoroutine);&#10;    }&#10;&#10;    private IEnumerator DelayLoading()&#10;    {&#10;        int sec = 20;&#10;&#10;        while (sec-- &gt; 0)&#10;        {&#10;            Vector3 targetLoadingRotation = new Vector3(0, 0, gameObject.transform.localRotation.eulerAngles.z+350);&#10;            &#10;            &#10;            yield return new WaitForSeconds(1.1f);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System.Collections;&#10;using UnityEngine;&#10;&#10;public class LoaderView : MonoBehaviour&#10;{&#10;    [Header(&quot;Rotation Settings&quot;)]&#10;    [SerializeField] private float rotationSpeed = 360f; // градусов в секунду&#10;    [SerializeField] private bool rotateOnEnable = true;&#10;    &#10;    private Coroutine _rotationCoroutine;&#10;    private bool _isRotating;&#10;&#10;    private void OnEnable()&#10;    {&#10;        if (rotateOnEnable)&#10;        {&#10;            StartRotation();&#10;        }&#10;    }&#10;&#10;    private void OnDisable()&#10;    {&#10;        StopRotation();&#10;    }&#10;&#10;    public void StartRotation()&#10;    {&#10;        if (!_isRotating)&#10;        {&#10;            _isRotating = true;&#10;            _rotationCoroutine = StartCoroutine(RotateObject());&#10;        }&#10;    }&#10;&#10;    public void StopRotation()&#10;    {&#10;        if (_rotationCoroutine != null)&#10;        {&#10;            StopCoroutine(_rotationCoroutine);&#10;            _rotationCoroutine = null;&#10;        }&#10;        _isRotating = false;&#10;    }&#10;&#10;    private IEnumerator RotateObject()&#10;    {&#10;        while (_isRotating)&#10;        {&#10;            // Плавное вращение вокруг Z-оси&#10;            transform.Rotate(0, 0, rotationSpeed * Time.deltaTime);&#10;            yield return null; // Ждем следующий кадр&#10;        }&#10;    }&#10;&#10;    public void SetRotationSpeed(float newSpeed)&#10;    {&#10;        rotationSpeed = newSpeed;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Assets/Scripts/OrientationBasedActivator.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/Scripts/OrientationBasedActivator.cs" />
              <option name="originalContent" value="using UnityEngine;&#10;&#10;public class OrientationBasedActivator : MonoBehaviour&#10;{&#10;    [Header(&quot;Target Object&quot;)]&#10;    [SerializeField] private GameObject targetObject;&#10;&#10;    private void Update()&#10;    {&#10;        if (targetObject == null)&#10;        {&#10;            Debug.LogWarning(&quot;Target object is not assigned.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Check the current screen orientation&#10;        if (Screen.orientation == ScreenOrientation.Landscape || Screen.orientation == ScreenOrientation.LandscapeLeft || Screen.orientation == ScreenOrientation.LandscapeRight)&#10;        {&#10;            // Enable the object in landscape mode&#10;            if (!targetObject.activeSelf)&#10;            {&#10;                targetObject.SetActive(true);&#10;            }&#10;        }&#10;        else if (Screen.orientation == ScreenOrientation.Portrait || Screen.orientation == ScreenOrientation.PortraitUpsideDown)&#10;        {&#10;            // Disable the object in portrait mode&#10;            if (targetObject.activeSelf)&#10;            {&#10;                targetObject.SetActive(false);&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using UnityEngine;&#10;&#10;public class OrientationBasedActivator : MonoBehaviour&#10;{&#10;    [Header(&quot;Target Object&quot;)]&#10;    [SerializeField] private GameObject targetObject;&#10;&#10;    [Header(&quot;Orientation Settings&quot;)]&#10;    [SerializeField] private bool disableInPortrait = true;&#10;    [SerializeField] private bool disableInLandscape = false;&#10;&#10;    private void Update()&#10;    {&#10;        if (targetObject == null)&#10;        {&#10;            Debug.LogWarning(&quot;Target object is not assigned.&quot;);&#10;            return;&#10;        }&#10;&#10;        // Check the current screen orientation&#10;        if ((Screen.orientation == ScreenOrientation.Landscape || Screen.orientation == ScreenOrientation.LandscapeLeft || Screen.orientation == ScreenOrientation.LandscapeRight) &amp;&amp; disableInLandscape)&#10;        {&#10;            // Disable the object in landscape mode&#10;            if (targetObject.activeSelf)&#10;            {&#10;                targetObject.SetActive(false);&#10;            }&#10;        }&#10;        else if ((Screen.orientation == ScreenOrientation.Portrait || Screen.orientation == ScreenOrientation.PortraitUpsideDown) &amp;&amp; disableInPortrait)&#10;        {&#10;            // Disable the object in portrait mode&#10;            if (targetObject.activeSelf)&#10;            {&#10;                targetObject.SetActive(false);&#10;            }&#10;        }&#10;        else&#10;        {&#10;            // Enable the object in other cases&#10;            if (!targetObject.activeSelf)&#10;            {&#10;                targetObject.SetActive(true);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>